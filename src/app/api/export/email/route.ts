import { NextResponse } from 'next/server';
import { Resend } from 'resend';
import { emailExportSchema } from '@/lib/validation';
import { createAdminClient } from '@/lib/supabase/server';
import { getErrorMessage } from '@/lib/utils';
import type { Result } from '@/types';

export async function POST(request: Request): Promise<NextResponse<Result<{ sent: boolean }>>> {
  try {
    const body = await request.json();

    // Validate input
    const validation = emailExportSchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json(
        { ok: false, error: validation.error.issues[0]?.message ?? 'Invalid input' },
        { status: 400 }
      );
    }

    const { jobId, email } = validation.data;

    // Check Resend API key
    const apiKey = process.env.RESEND_API_KEY;
    if (!apiKey) {
      return NextResponse.json(
        { ok: false, error: 'Email service not configured' },
        { status: 500 }
      );
    }

    // Fetch job and summary
    const supabase = createAdminClient();

    const { data: job, error: jobError } = await supabase
      .from('jobs')
      .select('*')
      .eq('id', jobId)
      .single();

    if (jobError || !job) {
      return NextResponse.json(
        { ok: false, error: 'Job not found' },
        { status: 404 }
      );
    }

    if (job.status !== 'completed') {
      return NextResponse.json(
        { ok: false, error: 'Job is not completed yet' },
        { status: 400 }
      );
    }

    const { data: summary, error: summaryError } = await supabase
      .from('summaries')
      .select('*')
      .eq('job_id', jobId)
      .single();

    if (summaryError || !summary) {
      return NextResponse.json(
        { ok: false, error: 'Summary not found' },
        { status: 404 }
      );
    }

    // Generate PDF for attachment
    const pdfBuffer = await generatePDF(
      summary.content,
      job.video_title ?? 'Podcast Summary'
    );

    // Send email with Resend
    const resend = new Resend(apiKey);

    const appUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3000';
    const jobUrl = `${appUrl}/job/${jobId}`;

    // Convert markdown summary to HTML for email
    const htmlSummary = markdownToHtml(summary.content);

    await resend.emails.send({
      from: 'Podcast Summary <onboarding@resend.dev>',
      to: email,
      subject: `Podcast Summary: ${job.video_title ?? 'Your Summary'}`,
      html: `
        <!DOCTYPE html>
        <html>
          <head>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
              h1 { color: #000; font-size: 24px; margin-bottom: 8px; }
              h2 { color: #333; font-size: 18px; margin-top: 24px; margin-bottom: 8px; }
              h3 { color: #555; font-size: 16px; margin-top: 16px; margin-bottom: 8px; }
              ul { padding-left: 20px; }
              li { margin-bottom: 8px; }
              blockquote { border-left: 4px solid #ddd; padding-left: 16px; margin: 16px 0; color: #666; font-style: italic; }
              .header { background: #f5f5f5; padding: 20px; border-radius: 8px; margin-bottom: 24px; }
              .footer { margin-top: 32px; padding-top: 16px; border-top: 1px solid #eee; color: #888; font-size: 14px; }
              .button { display: inline-block; padding: 12px 24px; background: #000; color: #fff !important; text-decoration: none; border-radius: 6px; margin-top: 16px; }
            </style>
          </head>
          <body>
            <div class="header">
              <h1>${job.video_title ?? 'Podcast Summary'}</h1>
              <p style="color: #666; margin: 0;">${job.video_channel ?? ''}</p>
            </div>

            ${htmlSummary}

            <div class="footer">
              <p>A PDF version is attached to this email.</p>
              <a href="${jobUrl}" class="button">View Online</a>
              <p style="margin-top: 24px;">Generated by Podcast Summary</p>
            </div>
          </body>
        </html>
      `,
      attachments: [
        {
          filename: `${sanitizeFilename(job.video_title ?? 'summary')}.pdf`,
          content: pdfBuffer,
        },
      ],
    });

    return NextResponse.json({
      ok: true,
      data: { sent: true },
    });
  } catch (error) {
    console.error('Error sending email:', error);
    return NextResponse.json(
      { ok: false, error: getErrorMessage(error) },
      { status: 500 }
    );
  }
}

/**
 * Generate a PDF buffer from summary content
 */
async function generatePDF(content: string, title: string): Promise<Buffer> {
  // Using jsPDF for server-side PDF generation
  const { default: jsPDF } = await import('jspdf');

  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const maxWidth = pageWidth - margin * 2;

  // Title
  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.text(title, margin, margin);

  // Content
  doc.setFontSize(11);
  doc.setFont('helvetica', 'normal');

  const lines = doc.splitTextToSize(content, maxWidth);
  let y = margin + 15;
  const lineHeight = 6;

  for (const line of lines) {
    if (y + lineHeight > pageHeight - margin) {
      doc.addPage();
      y = margin;
    }
    doc.text(line, margin, y);
    y += lineHeight;
  }

  // Footer on each page
  const pageCount = doc.internal.pages.length - 1;
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(9);
    doc.setTextColor(150);
    doc.text(
      `Generated by Podcast Summary â€¢ Page ${i} of ${pageCount}`,
      margin,
      pageHeight - 10
    );
  }

  // Return as Buffer
  const arrayBuffer = doc.output('arraybuffer');
  return Buffer.from(arrayBuffer);
}

/**
 * Simple markdown to HTML conversion for email
 */
function markdownToHtml(markdown: string): string {
  return markdown
    // Headers
    .replace(/^### (.*$)/gm, '<h3>$1</h3>')
    .replace(/^## (.*$)/gm, '<h2>$1</h2>')
    .replace(/^# (.*$)/gm, '<h1>$1</h1>')
    // Bold
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    // Italic
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    // Blockquotes
    .replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>')
    // Lists
    .replace(/^- (.*$)/gm, '<li>$1</li>')
    .replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>')
    // Paragraphs
    .replace(/\n\n/g, '</p><p>')
    .replace(/^(.+)$/gm, '<p>$1</p>')
    // Clean up empty paragraphs
    .replace(/<p><\/p>/g, '')
    .replace(/<p>(<h[123]>)/g, '$1')
    .replace(/(<\/h[123]>)<\/p>/g, '$1')
    .replace(/<p>(<ul>)/g, '$1')
    .replace(/(<\/ul>)<\/p>/g, '$1')
    .replace(/<p>(<blockquote>)/g, '$1')
    .replace(/(<\/blockquote>)<\/p>/g, '$1');
}

/**
 * Sanitize filename for PDF attachment
 */
function sanitizeFilename(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 50);
}
